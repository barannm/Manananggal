/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Matthias Barann, using modified code by Fabian Birzele
 */
package BioKit;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.RandomAccessFile;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * This class allows to access genes in GTF/GFF files given a index file (which can also be generated by using methods provided by this class).
 * 
 * It can be used to extract the gene information for a given gene without reading the whole GTF/GFF file. The files will be indexed using the
 * gene_id attribute, which might give different values for different GTF/GFF files (i.e. for Ensembl and Refgene).
 * 
 * @author Matthias Barann, using modified code by Fabian Birzele
 *
 */
public class RandomAccessGFFReader 
{
	class Range implements Comparable<Range>
	{
		int start;
		int end;
		
		@Override
		public int compareTo(Range other)
		{
			if(start == other.start)
			{
				return end - other.end;
			}
			
			return start - other.start;
		}
	};
	
	private HashMap<Integer, Long> 	m_pIndex;
	private TreeMap<String, TreeMap<Range, Long>>  m_pIndexPositions; 
	private RandomAccessFile 		m_pFileGTF;
	private String					m_strGTF;
	
	/**
	 * Initializes the random access reader. If the specified index file does not exist it is generated. This may take some time in the case of long files containing
	 * many transcripts. The index for the specified GTF/GFF file is then read to the system to allow for fast access of the data in the FASTA file.
	 * 
	 * @param GTF/GFF file
	 * @param index file
	 * @throws Exception
	 */
	public RandomAccessGFFReader(File pFileGTF, File pIndexFile) throws Exception
	{
		m_pFileGTF = new RandomAccessFile(pFileGTF, "r");
		m_strGTF   = pFileGTF.getAbsolutePath();
		
		if(pIndexFile.exists())
		{
			System.out.println("Read index file " + pIndexFile.getAbsolutePath());
			
			m_pIndex = new HashMap<Integer, Long>();
			m_pIndexPositions = new TreeMap<String, TreeMap<Range, Long>>();
			
			readFileIndex(pIndexFile);
			
			System.out.println("Indexed " + m_pIndex.size() + " sequences... done");
		}
		else
		{
			System.out.println("Create index for file " + pFileGTF.getAbsolutePath());
			
			m_pIndex = new HashMap<Integer, Long>();
			m_pIndexPositions = new TreeMap<String, TreeMap<Range, Long>>();
			
			createAndWriteIndexFile(pIndexFile);
			
			System.out.println("Indexed " + m_pIndex.size() + " sequences... done");
		}
	}
	
	/**
	 * Method can be used to close the current file handle
	 * 
	 * @throws IOException
	 */
	public void close() throws IOException
	{
		m_pIndex = null;
		m_pFileGTF.close();
	}
	
	/**
	 * Optimized version for read sequence files. Will only read the first line after the id has been hit
	 * 
	 * @param strGeneID
	 * @return
	 * @throws IOException 
	 * @throws Exception
	 */
	
	public String GetFileName()
	{
		return m_strGTF;
	}
	
	public long GetIndexForGene(String strGeneID)
	{
		int nHashID = strGeneID.hashCode();
		if(m_pIndex.containsKey(nHashID))
		{
			return m_pIndex.get(nHashID);
		}
		
		return 0;
	}
	
	public Gene ReadGene(String strGeneID) throws IOException
	{
		Gene gene = null;
		int nHashID = strGeneID.hashCode();
		if(m_pIndex.containsKey(nHashID))
		{
			long position = m_pIndex.get(nHashID);
			
			RandomAccessFile pReader = new RandomAccessFile(m_strGTF, "r");
			
			GTFParser parser = new GTFParser(pReader, position);
			gene = parser.nextGene().createGene();
			
			return gene;
		}
		
		System.out.println("Failed to read information for gene: " + strGeneID);
		return null;
	}
	
	public TreeSet<Gene> GetGenesForRange(String strRef, int nStart, int nEnd)
	{
		if(!m_pIndexPositions.containsKey(strRef))
		{
			System.out.println("RandomAcessGFFReader::GetGenesForRange() -> invalid reference name specified: " + strRef);
			return null;
		}
		
		TreeSet<Gene> vcGenes = new TreeSet<Gene>();
		
		RandomAccessFile pReader = null;
		try
		{
			pReader = new RandomAccessFile(m_strGTF, "r");
		}
		catch(Exception e)
		{
			System.out.println("failed to open file: " + m_strGTF);
			e.printStackTrace();
			return null;
		}
		
		for(Map.Entry<Range, Long> e : m_pIndexPositions.get(strRef).entrySet())
		{
			Range r = e.getKey();
			
			if(r.end < nStart)
				continue;
			
			if(r.start > nEnd)
				break;
			
			try
			{
				GTFParser parser = new GTFParser(pReader, e.getValue());
				Gene gene = parser.nextGene().createGene();
				vcGenes.add(gene);
			}
			catch(Exception ex)
			{
				System.out.println("failed to create GTF parser to parse file: " + m_strGTF);
				ex.printStackTrace();
				return null;
			}
		}
		
		try
		{
			pReader.close();
		}
		catch(Exception e)
		{
			System.out.println("failed to close file: " + m_strGTF);
			e.printStackTrace();
		}
		
		return vcGenes;
	}

	public void readFileIndex(File file) throws Exception
	{
		BufferedReader reader = new BufferedReader(new FileReader(file));
		String line = null;
		
		String[] split;
		int counter = 0;
		
		while((line = reader.readLine()) != null)
		{
			split = line.split("\\s+");
			
			Long nFileOffset = Long.parseLong(split[4]);
			
			m_pIndex.put(split[0].hashCode(), nFileOffset);
			
			String strRef 	= split[1];
			int nStart 		= Integer.parseInt(split[2]);
			int nEnd 		= Integer.parseInt(split[3]);
			
			if(m_pIndexPositions.containsKey(strRef))
			{
				TreeMap<Range, Long> mapRangeToFileOffset = m_pIndexPositions.get(strRef);
				Range r	= new Range();
				r.start	= nStart;
				r.end	= nEnd;
				
				mapRangeToFileOffset.put(r, nFileOffset);
			}
			else
			{
				TreeMap<Range, Long> mapRangeToFileOffset = new TreeMap<Range, Long>();
				Range r	= new Range();
				r.start	= nStart;
				r.end	= nEnd;
				
				mapRangeToFileOffset.put(r, nFileOffset);
				m_pIndexPositions.put(strRef, mapRangeToFileOffset);
			}
			
			counter++;
			
			if(counter%100000 == 0)
				System.out.println("Process Sequence " + counter);
		}
		
		reader.close();
	}
	
	/**
	 * Method creates and writes an index to the specified file. The GTF/GFF file must already have been set!
	 * 
	 * @param indexFile
	 * @throws Exception
	 */
	public void createAndWriteIndexFile(File indexFile) throws Exception
	{
		String strLine = null;
		
		BufferedReader pReader = new BufferedReader(new FileReader(new File(m_strGTF)));
		
		long nBytesRead = 0;		
		int counter = 0;
		
		boolean bGeneKeyWord = false;
		
		// determine file encoding
		int nFileMode = -1;	// -1 = UNKNOWN, 0 = UNIX, 1 = WINDOWS
		
		// determine file mode
		while(true)
		{
			int nChar = pReader.read();
			if(nChar == -1)
				break;
			
			char ch = (char)nChar;
			
			if(ch == '\n')
				nFileMode = 0;
			
			if(ch == '\r')
			{
				nChar = pReader.read();
				if(nChar == -1)
					break;
				
				ch = (char)nChar;
				if(ch == 'n')
					nFileMode = 1;
			}
		}
		pReader.close();
	
		if(nFileMode == -1)
		{
			System.out.println("RandomAccessGTFReader -> Unable to determine whether the file is in UNIX or Windows format.");
			
			// delete empty file
			File pFile = new File(m_strGTF);
			pFile.delete();
			return;
		}
		
		pReader.close();
		
		// read file contents and write index file
		pReader = new BufferedReader(new FileReader(new File(m_strGTF)));
		PrintWriter pWriter = new PrintWriter(new FileWriter(indexFile));
		
		while((strLine = pReader.readLine()) != null)
		{
			String pSplit[] = strLine.split("\t");
			
			if(pSplit.length == 9 && pSplit[2].equals("gene"))
			{
				bGeneKeyWord = true;
				
				// get gene identifier
				String pSplit2[] = pSplit[8].split("\\s+");
				
				String strGeneID = null;
				for(int i=0; i<pSplit2.length; i++)
				{
					if(pSplit2[i].equals("gene_id"))
					{
						strGeneID = pSplit2[i+1].split("\"")[1].trim().split("\\.")[0];
						break;
					}
				}

				m_pIndex.put(strGeneID.hashCode(), nBytesRead);
				
				String strRef 	= pSplit[0];
				int nStart 		= Integer.parseInt(pSplit[3]);
				int nEnd 		= Integer.parseInt(pSplit[4]);
				
				if(m_pIndexPositions.containsKey(strRef))
				{
					TreeMap<Range, Long> mapRangeToFileOffset = m_pIndexPositions.get(strRef);
					Range r	= new Range();
					r.start	= nStart;
					r.end	= nEnd;
					
					mapRangeToFileOffset.put(r, nBytesRead);
				}
				else
				{
					TreeMap<Range, Long> mapRangeToFileOffset = new TreeMap<Range, Long>();
					Range r	= new Range();
					r.start	= nStart;
					r.end	= nEnd;
					
					mapRangeToFileOffset.put(r, nBytesRead);
					m_pIndexPositions.put(strRef, mapRangeToFileOffset);
				}
				
				pWriter.println(strGeneID + "\t" + pSplit[0] + "\t" + pSplit[3] + "\t" + pSplit[4] + "\t" + nBytesRead);
				
				counter++;
				
				if(counter%100 == 0)
					System.out.println("Process Sequence " + counter);
			}
			
			if(counter < 10)
				System.out.println("Bytes: " + strLine.getBytes().length + " "+ strLine);
			
			if(nFileMode == 0)
				nBytesRead += strLine.getBytes("UTF-8").length + 1;
			else
				nBytesRead += strLine.getBytes("UTF-8").length + 2;
		}
		pReader.close();
		
		if(!bGeneKeyWord)
		{
			System.out.println("missing gene specific lines -> trying exon lines now");
			pReader = new BufferedReader(new FileReader(new File(m_strGTF)));
			
			nBytesRead = 0;		
			counter = 0;
			
			String strLastGene = null;
			String strGeneRef = "?";
			int nGeneStart = 0;
			int nGeneEnd = 0;
			long nGeneStartPos = -1;
			
			while((strLine = pReader.readLine()) != null)
			{
				String pSplit[] = strLine.split("\t");
				
				if(pSplit.length == 9 && pSplit[2].equals("exon"))
				{					
					// get gene identifier
					String pSplit2[] = pSplit[8].split("\\s+");
					
					String strGeneID = null;
					for(int i=0; i<pSplit2.length; i++)
					{
						if(pSplit2[i].equals("gene_id"))
						{
							strGeneID = pSplit2[i+1].split("\"")[1].trim().split("\\.")[0];
							break;
						}
					}
					
					String strRef 	= pSplit[0];
					int nStart 		= Integer.parseInt(pSplit[3]);
					int nEnd 		= Integer.parseInt(pSplit[4]);
					
					// skip if the gene ID is still the same
					if(!strGeneID.equals(strLastGene))
					{
						if(strGeneID != null)
						{
							m_pIndex.put(strGeneID.hashCode(), nBytesRead);
							
							if(m_pIndexPositions.containsKey(strRef))
							{
								TreeMap<Range, Long> mapRangeToFileOffset = m_pIndexPositions.get(strRef);
								Range r	= new Range();
								r.start	= nStart;
								r.end	= nEnd;
								
								mapRangeToFileOffset.put(r, nBytesRead);
							}
							else
							{
								TreeMap<Range, Long> mapRangeToFileOffset = new TreeMap<Range, Long>();
								Range r	= new Range();
								r.start	= nStart;
								r.end	= nEnd;
								
								mapRangeToFileOffset.put(r, nBytesRead);
								m_pIndexPositions.put(strRef, mapRangeToFileOffset);
							}
							
							pWriter.println(strLastGene + "\t" + strGeneRef + "\t" + nGeneStart + "\t" + nGeneEnd + "\t" + nGeneStartPos);
						}
						
						nGeneStart = nStart;
						nGeneEnd   = nEnd;
						
						strGeneRef = strRef;
								
						strLastGene = strGeneID;
						nGeneStartPos = nBytesRead;
					}
					else
					{
//						System.out.println("extending");
						nGeneEnd = nEnd;
					}
					
					counter++;
					
					if(counter%100 == 0)
						System.out.println("Process Sequence " + counter);
				}

				if(nFileMode == 0)
					nBytesRead += strLine.getBytes("UTF-8").length + 1;
				else
					nBytesRead += strLine.getBytes("UTF-8").length + 2;
			}

			if(strLastGene != null)
			{
				m_pIndex.put(strLastGene.hashCode(), nBytesRead);
				
				if(m_pIndexPositions.containsKey(strGeneRef))
				{
					TreeMap<Range, Long> mapRangeToFileOffset = m_pIndexPositions.get(strGeneRef);
					Range r	= new Range();
					r.start	= nGeneStart;
					r.end	= nGeneEnd;
					
					mapRangeToFileOffset.put(r, nBytesRead);
				}
				else
				{
					TreeMap<Range, Long> mapRangeToFileOffset = new TreeMap<Range, Long>();
					Range r	= new Range();
					r.start	= nGeneStart;
					r.end	= nGeneEnd;
					
					mapRangeToFileOffset.put(r, nBytesRead);
					m_pIndexPositions.put(strGeneRef, mapRangeToFileOffset);
				}
				
				pWriter.println(strLastGene + "\t" + strGeneRef + "\t" + nGeneStart + "\t" + nGeneEnd + "\t" + nGeneStartPos);
			// write last entry
			}
			
			pReader.close();
		}

		pWriter.flush();
		pWriter.close();
	}
	
	/**
	 * This method just creates the index file (at the specified location) for the specified GTF/GFF file. The index is not kept in RAM!
	 * 
	 * @param fasta
	 * @param indexFile
	 * @throws Exception
	 */
	public static void writeIndexFile(File pFileIn, File indexFile) throws Exception
	{
		String strLine = null;
		
		if(indexFile.exists())
		{
			System.out.println("Index for " + pFileIn.getAbsolutePath() + " exists at " + indexFile.getAbsolutePath() + ". Index will NOT BE GENERATED...");
			return;
		}
		
		RandomAccessFile pFileGTF = new RandomAccessFile(pFileIn, "r");
		
		PrintWriter writer = new PrintWriter(new FileWriter(indexFile));
		
		int counter = 0;
		long lastpointer = pFileGTF.getFilePointer();

		while((strLine = pFileGTF.readLine()) != null)
		{
			String pSplit[] = strLine.split("\t");
			
			if(pSplit.length == 9 && pSplit[2].equals("gene"))
			{
				// get gene identifier
				String pSplit2[] = pSplit[8].split("\\s+");
				
				String strGeneID = null;
				for(int i=0; i<pSplit2.length; i++)
				{
					if(pSplit2[i].equals("gene_id"))
					{
						strGeneID = pSplit2[i+1].split("\"")[1].trim().split("\\.")[0];
						break;
					}
				}
				
				writer.println(strGeneID + "\t" + pSplit[0] + "\t" + pSplit[3] + "\t" + pSplit[4] + "\t" + lastpointer);
				
				counter++;
				
				if(counter%100000 == 0)
					System.out.println("Process Sequence " + counter);
			}
			
			lastpointer = pFileGTF.getFilePointer();
		}
		
		writer.flush();
		writer.close();
		
		// reset pointer to 0
		pFileGTF.seek(0);
		pFileGTF.close();
	}
	
	public static void main(String[] args) throws Exception
	{
		if(args[0].equals("-index"))
		{
			writeIndexFile(new File(args[1]), new File(args[2]));
		}
	}
	
}
