/*
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Fabian Birzele
 */
package BioKit;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.RandomAccessFile;
import java.util.HashMap;
import java.util.Vector;

/**
 * This class allows to access specific positions in FASTA files given a index file (which can also be generated by using methods provided by this class).
 * 
 * It is for example used to access reads in a FASTA file in a fast way or to access all reads for a gene in sorted read files.
 * 
 * @author Fabian Birzele
 *
 */
public class RandomAccessFastaReader 
{
	private HashMap<Integer, Long> fileIndex;
	private RandomAccessFile fastaFile;
	private String indexFile;
	
	/**
	 * Initializes the random acces reader. If the specified index file does not exist it is generated. This may take some time in the case of long files containing
	 * many sequences. The index for the specified FASTA file is then read to the system to allow for fast access of the data in the FASTA file.
	 * 
	 * @param fastaFile
	 * @param indexFile
	 * @throws Exception
	 */
	public RandomAccessFastaReader(File fastaFile, File indexFile) throws Exception
	{
		this.fastaFile = new RandomAccessFile(fastaFile, "r");
		this.indexFile = indexFile.getAbsolutePath();
		
		if(indexFile.exists())
		{
			System.out.println("Read index file " + indexFile.getAbsolutePath());
			
			fileIndex = new HashMap<Integer, Long>();
			
			readFileIndex(indexFile);
			
			System.out.println("Indexed "+fileIndex.size()+" sequences... done");
		}
		else
		{
			System.out.println("Create index for file " + fastaFile.getAbsolutePath());
			
			fileIndex = new HashMap<Integer, Long>();
			
			createAndWriteIndexFile(indexFile);
			
			System.out.println("Indexed "+fileIndex.size()+" sequences... done");
		}
	}
	
	/**
	 * Method can be used to close the current file handle
	 * 
	 * @throws IOException
	 */
	public void close() throws IOException
	{
		fileIndex = null;
		fastaFile.close();
	}
	
	/**
	 * Optimized version for read sequence files. Will only read the first line after the id has been hit
	 * 
	 * @param idHashcode
	 * @return
	 * @throws Exception
	 */
	public String getSingleSequenceLineForIdHashcode(int idHashcode) throws Exception
	{
		if(fileIndex.containsKey(idHashcode))
		{
			long position = fileIndex.get(idHashcode);
		
			fastaFile.seek(position);
			
			String idLine = fastaFile.readLine();
			
			// make sure that the correct line has been hit
			if(idLine.substring(1).trim().hashCode() != idHashcode)
				throw new Exception("Indexed position does not fit to the id! Wrong index file? Searched for: " + idHashcode + " but found: " + idLine.substring(1).trim()+ " in index file " + indexFile);
			
			return fastaFile.readLine();
		}
		else
		{
			return null;
		}
	}
	
	/**
	 * Method jumps to the specified position and reads all lines that follow until the next id in the FASTA file
	 * 
	 * @param idHashcode
	 * @return
	 * @throws Exception
	 */
	public String getSequenceForIdHashcode(int idHashcode) throws Exception
	{
		if(fileIndex.containsKey(idHashcode))
		{
			long position = fileIndex.get(idHashcode);
		
			fastaFile.seek(position);
			
			String idLine = fastaFile.readLine();
			
			// make sure that the correct line has been hit
			if(idLine.substring(1).trim().hashCode() != idHashcode)
				throw new Exception("Indexed position does not fit to the id! Wrong index file? Searched for: " + idHashcode + " but found: " + idLine.substring(1).trim() + " in index file " + indexFile);
			
			StringBuffer sequence = new StringBuffer();
			
			String line = null;
			
			while((line = fastaFile.readLine()) != null)
			{
				if(line.startsWith(">"))
				{
					break;
				}
				else
				{
					sequence.append(line.trim());
				}
			}
			
			return sequence.toString();
		}
		else
		{
			return null;
		}
	}
	
	/**
	 * Method jumps to the specified position and reads all sequence lines from there. Single lines are treated as single sequences.
	 * 
	 * @param idHashcode
	 * @return
	 * @throws Exception
	 */
	public synchronized Vector<String> getSequencesForIdHashcode(int idHashcode) throws Exception
	{
		if(fileIndex.containsKey(idHashcode))
		{
			Vector<String> sequences = new Vector<String>();
			
			long position = fileIndex.get(idHashcode);
		
			fastaFile.seek(position);
			
			String idLine = fastaFile.readLine();
			
			// make sure that the correct line has been hit
			if(idLine.substring(1).trim().hashCode() != idHashcode)
				throw new Exception("Indexed position does not fit to the id! Wrong index file? Searched for: " + idHashcode + " but found: " + idLine.substring(1).trim().hashCode()+ " in index file " + indexFile);
			
			String line = null;
			
			while((line = fastaFile.readLine()) != null)
			{
				if(line.startsWith(">"))
				{
					break;
				}
				else
				{
					sequences.add(line.trim());
				}
			}
			
			return sequences;
		}
		else
		{
			System.out.println("Unknown id: " + idHashcode);
			return new Vector<String>();
		}
	}
	
	/**
	 * Method returns the sequence deposited for the specified id. The string id is converted to the corresponding hash code and method call is 
	 * forwarded to the getSequenceforId(int hashcode) method.
	 * 
	 * @param id
	 * @return
	 * @throws Exception
	 */
	public String getSequenceForId(String id) throws Exception
	{
		return getSequenceForIdHashcode(id.hashCode());
	}

	public void readFileIndex(File file) throws Exception
	{
		BufferedReader reader = new BufferedReader(new FileReader(file));
		String line = null;
		
		String[] split;
		int counter = 0;
		
		while((line = reader.readLine()) != null)
		{
			split = line.split("\\s+");
			fileIndex.put(split[0].hashCode(), Long.parseLong(split[1]));
			
			counter++;
			
			if(counter%100000 == 0)
				System.out.println("Process Sequence " + counter);
		}
		reader.close();
	}
	
	/**
	 * Method creates and writes an index to the specified file. The FASTA file must already have been set!
	 * 
	 * @param indexFile
	 * @throws Exception
	 */
	public void createAndWriteIndexFile(File indexFile) throws Exception
	{
		String line = null;
		
		PrintWriter writer = new PrintWriter(new FileWriter(indexFile));
		
		int counter = 0;
		long lastpointer = fastaFile.getFilePointer();
		
		while((line = fastaFile.readLine()) != null)
		{
			if(line.startsWith(">"))
			{
				fileIndex.put(line.substring(1).trim().hashCode(), lastpointer);
				writer.println(line.substring(1).trim() + "\t" + lastpointer);
				
				counter++;
				
				if(counter%100000 == 0)
					System.out.println("Process Sequence " + counter);
			}
			
			lastpointer = fastaFile.getFilePointer();
		}
		
		writer.flush();
		writer.close();
		
		// reset pointer to 0
		fastaFile.seek(0);
	}
	
	/**
	 * This method just creates the index file (at the specified location) for the specified FASTA file. The index is not read to the main memory!
	 * 
	 * @param fasta
	 * @param indexFile
	 * @throws Exception
	 */
	public static void writeIndexFile(File fasta, File indexFile) throws Exception
	{
		String line = null;
		
		if(indexFile.exists())
		{
			System.out.println("Index for " + fasta.getAbsolutePath() + " exists at " + indexFile.getAbsolutePath() + ". Index will NOT BE GENERATED...");
			return;
		}
		
		RandomAccessFile fastaFile = new RandomAccessFile(fasta, "r");
		
		PrintWriter writer = new PrintWriter(new FileWriter(indexFile));
		
		int counter = 0;
		long lastpointer = fastaFile.getFilePointer();

		while((line = fastaFile.readLine()) != null)
		{
			if(line.startsWith(">"))
			{
				writer.println(line.substring(1).trim() + "\t" + lastpointer);
				
				counter++;
				
				if(counter%100000 == 0)
					System.out.println("Process Sequence " + counter);
			}
			
			lastpointer = fastaFile.getFilePointer();
		}
		
		fastaFile.close();
		
		writer.flush();
		writer.close();
		
		/*
		// reset pointer to 0
		fastaFile.seek(0);
		*/
	}
	
	/**
	 * Method can be used to combine a set of FASTA files or sorted read files. 
	 * 
	 * @param outputFile
	 * @param geneList
	 * @param files
	 * @throws Exception
	 */
	public static void combineReplicates(String outputFile, String geneList, Vector<String> files) throws Exception
	{
		HashMap<String, RandomAccessFastaReader> readers = new HashMap<String, RandomAccessFastaReader>();
		
		// initialize reader
		for(String file : files)
		{
			RandomAccessFastaReader reader = new RandomAccessFastaReader(new File(file), new File(file + ".index"));
			
			readers.put(file, reader);
		}
		
		// now summarize data
		BufferedReader reader = new BufferedReader(new FileReader(geneList));
		PrintWriter writer = new PrintWriter(new FileWriter(outputFile));
		
		String line = null;
		
		while((line = reader.readLine()) != null)
		{
			Vector<String> sequences = new Vector<String>();
			String geneID = line.trim();
			int hash = geneID.hashCode();
			
			System.out.println("Summarize information for gene " + geneID + " " + hash);
			
			for(RandomAccessFastaReader rnd : readers.values())
			{
				sequences.addAll(rnd.getSequencesForIdHashcode(hash));
			}
			
			if(sequences.size() > 0)
			{
				writer.println(">" + geneID);
				
				for(String s : sequences)
				{
					writer.println(s);
				}
			}
		}
		reader.close();
		
		writer.flush();
		writer.close();
		
		System.out.println("Create index...");
		new RandomAccessFastaReader(new File(outputFile), new File(outputFile + ".index"));
	}
	
	/**
	 * This method allows to extract a set of reads for a gene in a specified file and writes those reads to the user defined output file.
	 * @param geneID
	 * @param readFile
	 * @param outputFile
	 * @throws Exception
	 */
	public static void extractReads(String geneID, String readFile, String outputFile) throws Exception
	{
		RandomAccessFastaReader reader = new RandomAccessFastaReader(new File(readFile), new File(readFile + ".index"));
		
		Vector<String> sequences = new Vector<String>();
		int hash = geneID.hashCode();
		
		sequences.addAll(reader.getSequencesForIdHashcode(hash));
		
		PrintWriter writer = new PrintWriter(new FileWriter(outputFile, true));
		
		int counter = 0;
		
		if(sequences.size() > 0)
		{
			for(String s : sequences)
			{
				writer.println(">" + geneID + "_" + counter);
				writer.println(s);
				
				counter++;
			}
		}
		
		System.out.println(counter + " reads written to file " + outputFile);
		
		writer.flush();
		writer.close();
	}
	
	public static void main(String[] args) throws Exception
	{
		if(args[0].equals("-index"))
		{
			writeIndexFile(new File(args[1]), new File(args[2]));
		}
		else if(args[0].equals("-combine"))
		{
			String outputFile = args[1];
			String geneList = args[2];
			
			Vector<String> files = new Vector<String>();
			
			for(int i=3; i<args.length; i++)
			{
				files.add(args[i]);
			}
			
			combineReplicates(outputFile, geneList, files);
		}
		else if(args[0].equals("-extract"))
		{
			String geneID = args[1];
			String outputFile = args[2];
			String readFile = args[3];
			
			extractReads(geneID, readFile, outputFile);
		}
	}
	
}
